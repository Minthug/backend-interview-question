Java 기본 개념에 대한 질문

1. 객체 지향 프로그래밍(OOP)의 4가지 주요 개념(캡슐화, 상속, 다형성, 추상화)에 대해 설명해주세요. 각 개념의 Java에서의 구현 방법도 간단히 언급해주세요.

객체 지향 프로그래밍이란 객체들이 모여 소통하고 협력하여 하나의 소프트웨어 프로그램을 이루는 패러다임 입니다

4가지 주요 개념이 OOP에 있는데 캡슐화,상속,다형성,추상화가 있습니다.

간단하게 캡슐화는 속성과 행위를 클래스로 묶는 것인데 데이터 보호와 은닉을 할 수 있습니다.
private 멤버 변수나 public 의 getter/setter method 사용이 있습니다.

상속은 기존 클래스의 속성과 메서드를 새로운 클래스가 재사용하는 것이고 
목적은 코드의 재사용과 계층 구조 표현에 있습니다.
주로 extends 키워드 사용해서 간단히 상속을 사용할 수 방법이 있습니다.

⭐️ 다형성은 같은 인터페이스나 메서드가 다른 구현을 가질 수 있는것을 말하는데 유연성과 확장성을 챙깁니다.
목적은 유연성과 확장성에 있고
자바에선 interface 구현이나 오버라이딩을 합니다.

추상화는 복잡한 시스템에서 핵심적인 개념이나 기능을 간추리는 것이며
목적 자체는 복잡성 감소와 설계의 유연성을 높이는 것입니다
abstract class를 사용하거나 interface를 사용하면 됩니다.

2. Java의 메모리 관리 방식에 대해 설명해주세요. 특히 가비지 컬렉션(Garbage Collection)의 작동 원리와 JVM의 메모리 구조(힙, 스택 등)에 대해 설명해주세요.

JVM의 메모리 구조는 
힙, 메서드, 스택, 피시 레지스터, 네이티브 메서드 스택가 있습니다.

힙 영역은 객체와 배열이 저장되는 곳으로 동적으로 생성되고 소멸되는 데이터를 관리합니다.
가비지 컬렉션의 주요 대상입니다.

메서드 영역은 클래스 구조와 메서드 데이터, 클래스 변수, 상수 등 정적인 데이터를 저장합니다.

스택 영역은 메서드 호출 시 생성되는 스택 프레임, 지역 변수, 매개 변수 등을 저장합니다.

피시 레지스터는 현재 실행중인 명령의 주소를 저장하고, 각 스레드마다 별도로 생성되고 스레드가 종료되면 삭제됩니다.

네이티브 메서드는 네이티브 메서드 정보를 저장합니다.

⭐️ -> 왜 힙만 저장 ?
동적 할당 : 힙영역은 런타임에 동적으로 객체가 생성되고 소멸하기 때문에 더 이상 사용되지 않는 객체를 식별하고 제거하는 과정이 더욱 필요하기 때문입니다.

힙 영역의 객체들은 "수명이 가변적"이며 프로그램 실행 중 언제든지 불필요해질 수도 있기 때문입니다.
메모리 관리 효율 부분에서도 다른 영역은 비교적 예측 가능한 방식이나 자동으로 정리되는 반면에 힙 영역은 복잡하고 동적인 메모리 사용 패턴을 가지고 있습니다.
또한 가비지 컬렉션을 통해 힙 메모리를 효율적으로 관리함으로써 전체적인 애플리케이션의 성능을 최적화할 수 있습니다.

자바는 가비지 컬렉터가 메모리 관리를 대행해주기 때문에 자바 프로세스에 한정된 메모리를 효율적으로 사용할 수 있고,
개발자는 개발에 더 집중할 수 있습니다.

가비지컬렉션의 동작원리는 객체 생성 > 객체 사용 > 참조 해제  > 가비지 컬렉션 동작 > 마킹 > 스위핑 > 압축  >메모리 반환 이루어지며, 마킹을 통해서 모든 접근 가능한 객체를 식별하고 마킹 한 뒤에 스위핑 과정에서 마킹에서 제외된 객체 메모리들을 제거하고 압축 과정에서 남은 객체들을 연속된 메모리 공간으로 이동시켜 단편화를 방지합니다.

-> 1. 작동 중 발생가능한 문제는 ?
Stop-the-world 현상으로 가비지컬레션이 동작하는 도중에 잠시 다른 활동을 멈춰야할 수도 있습니다.
또한 너무 자주 청소하면 시간이 많이 걸리고, 너무 드물게하면 메모리 부족 현상이 발생할 수도 있습니다.

3. 추상 클래스와 인터페이스의 차이점은 무엇인가요? 각각 어떤 상황에서 사용하는 것이 적합한지 예를 들어 설명해주세요.

같은 추상화인 인터페이스와 추상클래스의 다른 점은
추상 클래스는 클래스 간의 연관 관계를 구축하는 것에 초점을 둔다면 
인터페이스는 클래스의 특정 동작을 정의하고 다양한 클래스에서 공통 기능을 구현하는 것에 초점을 두고 있습니다.

추상 클래스는 여러 개의 클래스에 공통된 기능을 제공하고 싶을때, 
인터페이스는 완전히 다른 클래스들이 특정 동작을 반드시 구현하도록 강제하고싶으면 인터페이스를 사용하는 것 입니다.


4. Java의 예외 처리 메커니즘에 대해 설명해주세요. Checked Exception과 Unchecked Exception의 차이, 그리고 try-catch-finally 블록의 사용법에 대해 설명해주세요.

자바의 예외 처리 메커니즘은 throwable 최상위 클래스를 두고 error 와 exception이 하위 클래스로 나뉘는데
error는 심각하고 복구 불가능한 상황을 나타내고, exception은 프로그램 코드에 의해 처리될 수 있는 예외적인 상황을 나타냅니다.
(에러는 시스템 레벨의 심각한 문제로 대부분 프로그램에서 처리하지 않고, 주로 프로그램 종료로 이어짐)

checked 와 unchecked 차이는 
checked는 컴파일 타임에 체크되는 예외로 예상 가능한 처리 상황이거나 반드시 처리해야할 예외이고
unchecked는 런타임에 발생하는 예외로 프로그래밍 오류로 인한 예외 상황이고 checked와 달리 예외 처리를 강제로 하지 않습니다.

-------------------
try 블록
예외가 발생 가능성이 있는 코드를 포함시킵니다

catch 블록
try블록에서 발생한 예외를 처리하는 코드를 포함합니다
catch 블록은 여러개 작성이 가능하며 다양한 예외를 처리할 수 있습니다.
예외 타입은 범위가 좁은 것부터 넓은 순으로 작성해야 합니다.

finally 블록
예외 발생 여부와 관계없이 항상 실행되는 코드를 포함합니다.
무조건 사용이 아닌 선택적으로 사용이 가능합니다.
--------------------

```
1. try-with-resources란 무엇인가요? 
-> Java 7에서 도입된 기능으로, AutoCloseable 인터페이스를 구현한 리소스를 자동으로 닫아주는 구문입니다.
2. 예외를 무시하는 것(swallowing exceptions)의 문제점은 무엇인가요?
-> 디버깅을 어렵게 만들고, 잠재적인 버그를 숨길 수 있어 프로그램의 안정성을 해칠 수 있습니다.
```


5. 자바의 컬렉션 프레임워크에 대해 설명해주세요. 
List, Set, Map 인터페이스의 주요 특징과 그 구현 클래스들의 차이점을 설명해주세요.

자바 컬렉션 프레임워크는 데이터를 저장하고 처리하기 위한 일관된 구조의 클래스와 인터페이스 집합입니다.
인터페이스와 다형성을 이용한 객체 지향적 설계를 통해 표준화되어있어서 사용법을 익히기에 편하고 재사용성이 높습니다.

> 장점은 ?

List 
List는 순서가 있고 중복을 허용하는 데이터 구조입니다.
주요 클래스로는 ArrayList와 LinkedList가 있으며 
Array리스트는 내부적으로 동적 배열을 사용해 빠른 랜덤 접근이 가능하지만 중간 삽입/삭제가 느립니다.

Linked리스트는 이중 연결 리스트로 구현되어 중간 삽입/삭제가 빠르지만 랜덤 접근이 느립니다.

> 순서가 중요하거나 중복 요소를 허용할 때 사용(예. 최근 검색기록, 대기열)

Set
set은 중복을 허용하지 않는 데이터 구조입니다.
HashSet 과 TreeSet, LinkedHashSet이 있으며
해쉬셋은 해시 테이블을 사용해 가장 빠른 검색과 삽입을 제공하지만, 순서를 보장하지않습니다.

트리셋은 이진 검색 트리를 사용해 요소를 정렬된 상태로 유지합니다.

링크드해쉬셋은 해쉬셋에 링크드리스트 결합하여 삽입 순서를 유지합니다
요소의 고유성, 검색 속도, 정렬 필요성 등을 고려하여 적절한 Set을 선택해야합니다.

> 중복을 허용치 않고 고유한 데이터 집합이 필요할 때(예. 고유 식별자, 방문한 웹 페이지 URL) 

Map
맵은 키-값 쌍으로 데이터를 저장하는 구조입니다.
HashMap, TreeMap, LinkedHashMap 이 있으며

해쉬맵은 해시 테이블을 사용하여 빠른 검색과 삽입을 제공하지만 순서는 보장하지 않습니다.

트리맵은 레드-블랙 트리를 사용해 키를 기준으로 정렬된 상태를 유지 합니다.

링크드해쉬드맵은 해쉬맵에 링크드리스트를 결합해 삽입 순서나 접근 순서를 유지할 수 있습니다.

> 키 - 값 쌍 데이터를 저장하고 검색해야 할 때 (예. 캐시, 설정 정보, 사전)

6. 멀티스레딩이란 무엇이며, Java에서 어떻게 구현할 수 있나요? 스레드의 생명주기와 동기화 방법에 대해 설명해주세요.
하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생산과 관리의 중요성을 최소화하여 수행 능력을 향상하는것
여러 개의 스레드를 통해 하나의 프로그램에서 동시에 여러 개의 일을 수행할 수 있도록 해주는 것

Thread 클래스 상속과 Runnable 인터페이스 구현 그리고 Executor 프레임워크를 사용하는
3 가지의 방법이 있습니다.
뜨레드와 러너블을 이용한 두 가지 방식은 기본적인 스레드 생성 방법이지만 프로덕션 환경에서는 여러 한계점이 있습니다
> 한계점이? 1. 스레드 생성과 소멸의 오버헤드 2. 스레드 수의 제한적 제어 3. 작업 큐잉, 스레드 재사용 등의 기능 부재

스레드의 생명주기는 new -> runnalbe -> running -> blocked -> Dead 의 순서로
스레드가 생성되고 start() 메서드 호출하면 Runnalbe 상태로 이동하는데 Runnalbe 상태에서 쓰레드 스케쥴러에 의해 러닝상태로 이동하게 된다음 스레드가 특정 이유로 러닝 상태에서 블록상태로 이동하게 된다.
블록 단계는 동기화 메서드 혹은 동기화 블록을 실행하기 위해 먼저 실행중인 쓰레드를 실행 완료를 기다리는 상태이다
쓰레드가 종료되면 그 쓰레드는 다시 시작할 수없게 데드 단계에서 처리된다.

동기화 방법은 Synchronized 키워드, Volatile 키워드, concurrent 패키지가 있습니다.
싱크로나이즈드 키워드는 메소드나 블록에 사용하여 한 번에 하나의 스레드만 접근할 수 있게합니다.
가장 기본적인 방법입니다.

Volatile 키워드는 멀티 스레드 상황에서 하나의 스레드가 write&read하고 나머지 스레드가 읽는 상황에 경우에 적합합니다.

Concurrent 패키지 자바 5에서 추가된 패키지로, 동기화가 필요한 상황에 사용할 수 있는 유틸리티 클래스를 제공합니다.
```
Concurrent 패키지 설명해주세요 

동시성 컬렉션
- ConcurrentHashMap 여러 쓰레드가 동시에 읽고 쓸 수 있으며, 전체 맵을 락하지 않고 특정 부분에만 락을 겁니다.
실행자 프레임워크
- ExecutorService 스레드 풀을 관리하고 비동기 작업 실행을 단순화합니다.
동기화 유틸리티
동시성 큐
원자적 변수
```


7. Java의 접근 제어자(public, protected, default, private)의 차이점과 사용 목적에 대해 설명해주세요. 캡슐화와 어떤 관련이 있는지도 언급해주세요.
네
public 모든 접근을 허용하여 외부 클래스에서도 자유롭게 사용할 수 있습니다.
protected 같은 클래스나 이를 상속받은 하위클래스에서만 접근이 가능 합니다.
default 자신과 같은 패키지에 소속된 클래스만 접근할 수 있습니다
private 같은 클래스 내에서만 접근 가능하며 외부에서는 접근이 불가합니다.

퍼블릭은 어디서든 사용 가능한 공개 API를 만들때 사용하고
프로텍트는 상속 관계에서 상위 클래스의 기능을 하위클래스에서 사용하게 할 때 사용하고
디폴트는 같은 패키지내에서만 사용하는 클래스 또는 멤버를 정의할 때 쓰고.
프라이빗은 클래스 내부에서만 사용하는 멤버를 정의할때 쓰며.

캡슐화와 관계에 대해선 프라이빗을 사용해 클래스 내부 상태를 숨기고, 퍼블릭 메서드를 통해 제어된 방식으로만 내부 상태에 접근 가능하도록 함으로써 캡슐화를 구현합니다.

