Java 기본 개념에 대한 질문

1. 객체 지향 프로그래밍(OOP)의 4가지 주요 개념(캡슐화, 상속, 다형성, 추상화)에 대해 설명해주세요. 각 개념의 Java에서의 구현 방법도 간단히 언급해주세요.


2. Java의 메모리 관리 방식에 대해 설명해주세요. 특히 가비지 컬렉션(Garbage Collection)의 작동 원리와 JVM의 메모리 구조(힙, 스택 등)에 대해 설명해주세요.

JVM의 메모리 구조는 
힙, 메서드, 스택, 피시 레지스터, 네이티브 메서드 스택가 있습니다.

힙 영역은 객체와 배열이 저장되는 곳으로 동적으로 생성되고 소멸되는 데이터를 관리합니다.
가비지 컬렉션의 주요 대상입니다.

메서드 영역은 클래스 구조와 메서드 데이터, 클래스 변수, 상수 등 정적인 데이터를 저장합니다.

스택 영역은 메서드 호출 시 생성되는 스택 프레임, 지역 변수, 매개 변수 등을 저장합니다.

피시 레지스터는 현재 실행중인 명령의 주소를 저장하고, 각 스레드마다 별도로 생성되고 스레드가 종료되면 삭제됩니다.

네이티브 메서드는 네이티브 메서드 정보를 저장합니다.

-> 왜 힙만 저장 ?
동적 할당 : 힙영역은 런타임에 동적으로 객체가 생성되고 소멸하기 때문에 더 이상 사용되지 않는 객체를 식별하고 제거하는 과정이 더욱 필요하기 때문이고
힙 영역의 객체들은 "수명이 가변적"이며 프로그램 실행 중 언제든지 불필요해질 수도 있기 때문입니다.
메모리 관리 효율 부분에서도 다른 영역은 비교적 예측 가능한 방식이나 자동으로 정리되는 반면에 힙 영역은 복잡하고 동적인 메모리 사용 패턴을 가지고 있습니다.
또한 가비지 컬렉션을 통해 힙 메모리를 효율적으로 관리함으로써 전체적인 애플리케이션의 성능을 최적화할 수 있습니다.

자바는 가비지 컬렉터가 메모리 관리를 대행해주기 때문에 자바 프로세스에 한정된 메모리를 효율적으로 사용할 수 있고,
개발자는 개발에 더 집중할 수 있습니다.

가비지컬렉션의 동작원리는 객체 생성 > 객체 사용 > 참조 해제  > 가비지 컬렉션 동작 > 마킹 > 스위핑 > 압축  >메모리 반환 이루어지며, 마킹을 통해서 모든 접근 가능한 객체를 식별하고 마킹 한 뒤에 스위핑 과정에서 마킹에서 제외된 객체 메모리들을 제거하고 압축 과정에서 남은 객체들을 연속된 메모리 공간으로 이동시켜 단편화를 방지합니다.

-> 1. 작동 중 발생가능한 문제는 ?
Stop-the-world 현상으로 가비지컬레션이 동작하는 도중에 잠시 다른 활동을 멈춰야할 수도 있습니다.
또한 너무 자주 청소하면 시간이 많이 걸리고, 너무 드물게하면 메모리 부족 현상이 발생할 수도 있습니다.

3. 추상 클래스와 인터페이스의 차이점은 무엇인가요? 각각 어떤 상황에서 사용하는 것이 적합한지 예를 들어 설명해주세요.
추상 클래스와 인터페이스의 차이점에 가장 큰 부분은 
추상 클래스는 단일 상속을 인터페이스는 다중 구현을 지원한다(인터페이스끼리 다중 상속이 가능)

인터페이스는 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용하는 것에 초점
추상 클래스를 사용함으로써, 공통된 속성과 메서드를 한 곳에 모아 코드 중복을 줄이고, 동시에 각 하위 클래스가 필요한 메서드를 반드시 구현하도록 강제하며, 필요에 따라 기능을 확장할 수 있는 유연성을 제공합니다.
같은 추상화인 인터페이스와 다른점은, 추상클래스는 클래스간의 연관 관계를 구축하는 것에 초점을 둔다.
인터페이스는 클래스의 특정 동작을 정의하고 다양한 클래스에서 공통 기능을 구현하는 것에 초점을 둔다.

추상 클래스는 여러 개의 클래스에 공통된 기능을 제공하고 싶을때, 
인터페이스는 완전히 다른 클래스들이 특정 동작을 반드시 구현하도록 강제하고싶으면 인터페이스를 사용하는것

4. Java의 예외 처리 메커니즘에 대해 설명해주세요. Checked Exception과 Unchecked Exception의 차이, 그리고 try-catch-finally 블록의 사용법에 대해 설명해주세요.

자바의 예외 처리 메커니즘은 throwable 최상위 클래스를 두고 error 와 exception이 하위 클래스로 나뉘는데
error는 심각하고 복구 불가능한 상황을 나타내고, exception은 프로그램 코드에 의해 처리될 수 있는 예외적인 상황을 나타냅니다.
(에러는 시스템 레벨의 심각한 문제로 대부분 프로그램에서 처리하지 않고, 주로 프로그램 종료로 이어짐)

checked 와 unchecked 차이는 
checked는 컴파일 타임에 체크되는 예외로 예상 가능한 처리 상황이거나 반드시 처리해야할 예외이고
unchecked는 런타임에 발생하는 예외로 프로그래밍 오류로 인한 예외 상황이고 checked와 달리 예외 처리를 강제로 하지 않습니다.

try 블록
예외가 발생 가능성이 있는 코드를 포함시킵니다

catch 블록
try블록에서 발생한 예외를 처리하는 코드를 포함합니다
catch 블록은 여러개 작성이 가능하며 다양한 예외를 처리할 수 있습니다.
예외 타입은 범위가 좁은 것부터 넓은 순으로 작성해야 합니다.

finally 블록
예외 발생 여부와 관계없이 항상 실행되는 코드를 포함합니다.
주로 리소스 해제 등 정리 작업에 사용되고
무조건 사용이 아닌 선택적으로 사용이 가능합니다.

```
1. try-with-resources란 무엇인가요? 
-> Java 7에서 도입된 기능으로, AutoCloseable 인터페이스를 구현한 리소스를 자동으로 닫아주는 구문입니다.
2. 예외를 무시하는 것(swallowing exceptions)의 문제점은 무엇인가요?
-> 디버깅을 어렵게 만들고, 잠재적인 버그를 숨길 수 있어 프로그램의 안정성을 해칠 수 있습니다.
```


5. 자바의 컬렉션 프레임워크에 대해 설명해주세요. List, Set, Map 인터페이스의 주요 특징과 그 구현 클래스들의 차이점을 설명해주세요.
자바 컬렉션 프레임워크는 데이터를 저장하고 처리하기 위한 일관된 구조의 클래스와 인터페이스 집합입니다.
인터페이스와 다형성을 이용한 객체 지향적 설계를 통해 표준화되어있어서 사용법을 익히기에 편하고 재사용성이 높습니다.

> 장점은 ?

List 
List는 순서가 있고 중복을 허용하는 데이터 구조입니다.
주요 클래스로는 ArrayList와 LinkedList가 있으며 
Array리스트는 내부적으로 동적 배열을 사용해 빠른 랜덤 접근이 가능하지만 중간 삽입/삭제가 느립니다.

Linked리스트는 이중 연결 리스트로 구현되어 중간 삽입/삭제가 빠르지만 랜덤 접근이 느립니다.

> 순서가 중요하거나 중복 요소를 허용할 때 사용(예. 최근 검색기록, 대기열)

Set
set은 중복을 허용하지 않는 데이터 구조입니다.
HashSet 과 TreeSet, LinkedHashSet이 있으며
해쉬셋은 해시 테이블을 사용해 가장 빠른 검색과 삽입을 제공하지만, 순서를 보장하지않습니다.

트리셋은 이진 검색 트리를 사용해 요소를 정렬된 상태로 유지합니다.

링크드해쉬셋은 해쉬셋에 링크드리스트 결합하여 삽입 순서를 유지합니다
요소의 고유성, 검색 속도, 정렬 필요성 등을 고려하여 적절한 Set을 선택해야합니다.

> 중복을 허용치 않고 고유한 데이터 집합이 필요할 때(예. 고유 식별자, 방문한 웹 페이지 URL) 

Map
맵은 키-값 쌍으로 데이터를 저장하는 구조입니다.
HashMap, TreeMap, LinkedHashMap 이 있으며

해쉬맵은 해시 테이블을 사용하여 빠른 검색과 삽입을 제공하지만 순서는 보장하지 않습니다.

트리맵은 레드-블랙 트리를 사용해 키를 기준으로 정렬된 상태를 유지 합니다.

링크드해쉬드맵은 해쉬맵에 링크드리스트를 결합해 삽입 순서나 접근 순서를 유지할 수 있습니다.

> 키 - 값 쌍 데이터를 저장하고 검색해야 할 때 (예. 캐시, 설정 정보, 사전)

멀티스레딩이란 무엇이며, Java에서 어떻게 구현할 수 있나요? 스레드의 생명주기와 동기화 방법에 대해 설명해주세요.


Java의 접근 제어자(public, protected, default, private)의 차이점과 사용 목적에 대해 설명해주세요. 캡슐화와 어떤 관련이 있는지도 언급해주세요.