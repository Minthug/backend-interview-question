OOP Deep

1. SOLID 원칙에 대해 설명해주세요. 각 원칙의 의미와 이를 Java로 구현하는 방법에 대해 예를 들어 설명해주세요.

'S'imple Responsebility Principle
단일 책임 원칙
한 클래스는 하나의 책임을 져야한다
사용자 관리 클래스와 이메일 발송 클래스를 분리하는 것입니다

'O'pen-closed Principle
개방-폐쇄 원칙
소프트웨어 개체는 확장에는 열려있어야하고, 수정엔 닫혀야한다.
새로운 도형을 추가할 때 기존 코드를 수정하지 않고 Shape 인터페이스를 구현하는 방식입니다.

'L'iskov Substitution Principle
리스코프 치환 원칙
프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀수 있어야 한다
Bird 클래스의 fly() 메소드를 FlyableBird 인터페이스로 분리하여 모든 Bird가 반드시 날 수 있어야 한다는 제약을 없앱니다

'I'nterface Segregation Principle
인터페이스 분리 원칙
클라이언트는 자신이 허용하지 않은 메서드에 의존 관계를 맺으면 안된다.
Worker 인터페이스를 Workable과 Eatable로 분리하여 로봇 작업자가 불필요한 eat() 메서드를 구현하지 않도록 합니다

'D'ependency Inversion Principle
의존관계 역전 원칙
고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다, 둘 다 추상화에 의존해야한다.
Switch 클래스가 구체적인 LightBulb 대신 Switchable 인터페이스에 의존하도록 하여 다양한 기기를 제어할 수 있게 합니다

2. 의존성 주입(Dependency Injection)이란 무엇이며, 이것이 왜 중요한가요? Java에서 어떻게 구현할 수 있나요?
의존성 주입은 객체가 필요로 하는 의존성을 외부에서 제공하는 디자인 패턴입니다.

DI가 중요한 이유는 결합도 감소와 유연성 그리고 관심사의 분리이 있으며 테스트가 용이해진다는 점입니다.

서비스 클래스에서 생성자를 주입을 하거나 혹은 @Autowired 어노테이션을 사용한 필드 주입이 있습니다.

3. 컴포지션(Composition)과 상속의 차이점은 무엇인가요? "상속보다는 컴포지션을 사용하라"는 원칙에 대해 어떻게 생각하시나요?
둘의 차이점은 상속은 상위 클래스의 특성을 하위 클래스가 물려받고 강한 결합도와 단일 상속에 있습니다.
컴포지션을 사용하라는 원칙에 대해서는 상황에 따라 맞게 사용하는 방법이 좋지만 대게 결합도를 느슨하게하고 다중 상속으로 다른 객체를 포함한 기능 구현이 용이해는 점과 캡슐화 향상으로 인한 점이 있지만 너무 과도하게 컴포지션만 사용하는것이 아닌
말했다시피 상황에 맞는 방법을 쓰는게 좋을거같습니다.

4. 디자인 패턴 중 싱글톤(Singleton) 패턴에 대해 설명해주세요. Java에서 어떻게 구현하며, 어떤 상황에서 사용하나요?
싱글톤 패턴이란 
클래스의 인스턴스가 오직 하나만 생성되도록 보장하는 패턴입니다.

예를 들면 데이터베이스매니저 클래스를 만들고 그 안에 생성자를 private로 선언해서 외부에서 직접 인스턴스 생성을 막습니다.
물론 private static 변수를 만들어 유일하게 인스턴스 저장할수 있게 선언도 합니다.

이렇게 전체 애플리케이션에서 데이터베이스매니저의 인스턴스는 단 하나만 존재하게 됩니다.

이 외 전역 상태 관리, 설정 정보 관리 등에 활용하는 편입니다.

5. 개방-폐쇄 원칙(Open-Closed Principle)이란 무엇이며, 이를 Java 코드로 어떻게 구현할 수 있나요?


6. 인터페이스 분리 원칙(Interface Segregation Principle)에 대해 설명해주세요. 이 원칙을 적용했을 때의 장점은 무엇인가요?

인터페이스 분리원칙은 클라이언트는 자신이 허용하지 않은 메서드에 의존 관계를 맺으면 안된다 를 말하고있습니다.
이 원칙의 장점에 대해 말한다면 큰 인터페이스를 더 작고 특정한 인터페이스로 분리하는것인데
코드의 유연성과 재사용성을 향상하는데 좋고 코드 수정의 영향 범위가 축소됩니다.
따라서 명확하고 집중된 인터페이스 설계에 장점을 갖고있습니다.

7. 리스코프 치환 원칙(Liskov Substitution Principle)이란 무엇이며, 이 원칙을 위반하는 흔한 예와 해결 방법은 무엇인가요?

리스코프 치환 원칙은 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀수 있어야 한다
의 중점을 두고 있으며 

흔한 예를 간단히 설명하면 버드 클래스를 만들고 메서드로 새는 난다 를 제시했을때
펭귄 클래스가 나왓을때 예외가 발생합니다

해결책은
날 수 있는 새라는 인터페이스를 구현하고 펭귄은 이 인터페이스에 구현하지 않습니다.
물론 날 수 없는 새라는 인터페이스를 새로 구현해 정의해
각 타입은 자신의 능력에 맞는 동작만 수행하게 하는것입니다.

이로써 각 클래스는 자신의 능력에 맞는 메서드만 갖게하는것이 해결책입니다.


